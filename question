ðŸ’¡ å®žçŽ°æ–¹å¼ç›¸å…³
Why did you choose to use ExpandedObjectHeader instead of a lighter struct or native C struct for in-memory layout?
â†’ æƒ³äº†è§£ä½¿ç”¨ PostgreSQL å†…éƒ¨çš„ expanded object API è€Œä¸æ˜¯è‡ªå®šä¹‰ç»“æž„çš„åŽŸå› ï¼Œæ˜¯ä¸ºäº†æ›´å¥½åœ°é›†æˆ PG å†…æ ¸ï¼Œè¿˜æ˜¯ä¸ºäº†å®žçŽ° flatten/expandï¼Ÿ
What are the design tradeoffs between using uthash versus using PostgreSQLâ€™s own hash table infrastructure (e.g., dynahash)?
â†’ uthash æ˜¯è½»é‡ä½†æ²¡æœ‰å†…å»ºçš„ memory context æ”¯æŒï¼ŒPG å†…ç½®çš„ hash table å¯èƒ½é›†æˆæ›´ç´§å¯†ã€‚
Is it safe to use a collection type as a field in composite types or pass between functions that cross memory contexts?
â†’ å½“å‰ memory context éš”ç¦»ç­–ç•¥æ˜¯å¦å…è®¸è·¨å‡½æ•°å®‰å…¨ä½¿ç”¨ï¼Œflatten æ˜¯å¦æ˜¯å¿…è¦æ­¥éª¤ï¼Ÿ
Why limit to only text as key? Any plans to support other key types like int or uuid in the future?
â†’ ç›®å‰åªæ”¯æŒ text ç±»åž‹ keyï¼Œä½†å®žé™…ä¸šåŠ¡ä¸­å¸¸è§ int/uuid ä½œä¸ºä¸»é”®ã€‚
Why isn't there support for nested collections (collections inside collections)?
â†’ æ˜¯å¦æœ‰è®¾è®¡é™åˆ¶ï¼Œæˆ–åªæ˜¯ v1 å°šæœªæ”¯æŒï¼Ÿæ˜¯å¦æœ‰è®¡åˆ’å®žçŽ°ç±»ä¼¼åµŒå¥— map ç»“æž„ï¼Ÿ



What are the advantages of pgcollection over JSON?
1. Strongly typed values
Unlike JSON, which stores data as untyped strings or loosely structured objects, pgcollection enforces a consistent data type for all values. When you create a collection, you can define that all values must be text, integer, date, or even complex types like record. This helps catch type errors early and allows PostgreSQL to optimize memory and operations more efficiently.

2. Fast key-based access (O(1) vs. linear search)
pgcollection uses an internal hash table (via uthash) to store and retrieve key-value pairs. This means accessing a value by key takes constant time, regardless of the size of the collection. In contrast, accessing a value in a JSON object within PL/pgSQL often involves parsing the entire structure and doing a linear scan, which becomes slower as the JSON grows.

3. Optimized for in-memory usage
pgcollection is designed for temporary, high-speed operations inside functions, especially in PL/pgSQL. All data lives in memory and never touches disk unless explicitly saved. This makes it ideal for use cases like caching, aggregation, or building intermediate results during a complex computation.

4. Native subscript syntax
Accessing elements in a collection is straightforward and readable: collection['key'] := 'value'; or collection['key']. Thereâ€™s no need to cast or extract from a JSON blob using functions like ->> or jsonb_extract_path_text(). This syntax improves developer productivity and clarity.

5. Built-in iteration tools
pgcollection supports iterators like first(), next(), key(), and value() to loop over elements in order. This is more natural and efficient than trying to unpack and traverse a JSON structure inside a PL/pgSQL loop. You donâ€™t need to call jsonb_each() or convert JSON into a temporary table â€” pgcollection provides direct, in-memory iteration.
