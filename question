💡 实现方式相关
Why did you choose to use ExpandedObjectHeader instead of a lighter struct or native C struct for in-memory layout?
→ 想了解使用 PostgreSQL 内部的 expanded object API 而不是自定义结构的原因，是为了更好地集成 PG 内核，还是为了实现 flatten/expand？
What are the design tradeoffs between using uthash versus using PostgreSQL’s own hash table infrastructure (e.g., dynahash)?
→ uthash 是轻量但没有内建的 memory context 支持，PG 内置的 hash table 可能集成更紧密。
Is it safe to use a collection type as a field in composite types or pass between functions that cross memory contexts?
→ 当前 memory context 隔离策略是否允许跨函数安全使用，flatten 是否是必要步骤？
Why limit to only text as key? Any plans to support other key types like int or uuid in the future?
→ 目前只支持 text 类型 key，但实际业务中常见 int/uuid 作为主键。
Why isn't there support for nested collections (collections inside collections)?
→ 是否有设计限制，或只是 v1 尚未支持？是否有计划实现类似嵌套 map 结构？



What are the advantages of pgcollection over JSON?
1. Strongly typed values
Unlike JSON, which stores data as untyped strings or loosely structured objects, pgcollection enforces a consistent data type for all values. When you create a collection, you can define that all values must be text, integer, date, or even complex types like record. This helps catch type errors early and allows PostgreSQL to optimize memory and operations more efficiently.

2. Fast key-based access (O(1) vs. linear search)
pgcollection uses an internal hash table (via uthash) to store and retrieve key-value pairs. This means accessing a value by key takes constant time, regardless of the size of the collection. In contrast, accessing a value in a JSON object within PL/pgSQL often involves parsing the entire structure and doing a linear scan, which becomes slower as the JSON grows.

3. Optimized for in-memory usage
pgcollection is designed for temporary, high-speed operations inside functions, especially in PL/pgSQL. All data lives in memory and never touches disk unless explicitly saved. This makes it ideal for use cases like caching, aggregation, or building intermediate results during a complex computation.

4. Native subscript syntax
Accessing elements in a collection is straightforward and readable: collection['key'] := 'value'; or collection['key']. There’s no need to cast or extract from a JSON blob using functions like ->> or jsonb_extract_path_text(). This syntax improves developer productivity and clarity.

5. Built-in iteration tools
pgcollection supports iterators like first(), next(), key(), and value() to loop over elements in order. This is more natural and efficient than trying to unpack and traverse a JSON structure inside a PL/pgSQL loop. You don’t need to call jsonb_each() or convert JSON into a temporary table — pgcollection provides direct, in-memory iteration.


How pgcollection really aligns (or not) with Oracle collection kinds
Aspect	Oracle VARRAY / Nested‑table	Oracle Associative array	pgcollection reality
Bounded vs. unbounded	VARRAY is bounded ; Nested‑table is unbounded	Unbounded	Unbounded until memory (or 1 GB when flattened to disk) exhausts – so this matches Nested‑table/associative array behaviour.
Index/key type	VARRAY/Nested‑table use integer subscripts starting at 1	Can be integer or string	Currently only text keys. You cannot use an integer subscript unless you cast it to text. Future work could add an integer path, but today it is string‑only.
Sparsity	VARRAY dense, Nested‑table can be sparse after DELETE	Associative arrays can be sparse	pgcollection is hash‑based and therefore naturally sparse. Keys are not required to be contiguous or sequential.
On‑disk persistence	Nested‑table/ VARRAY columns stored as separate child tables or LOBs, support indexing and query	Associative array cannot be stored in a column	pgcollection can be stored in a column, but as a single varlena blob (max 1 GB) – there is no child table, no column‑level indexing, and the server must fully expand the blob to query it. So it is persistible like a nested table but without relational visibility or indexes.
Ordering semantics	VARRAY keeps positional order; Nested‑table loses order unless you ORDER BY; Associative array order undefined	pgcollection preserves insertion order until you call sort().	
Key take‑aways
Index datatype is indeed only text today.
All subscripts are stored as strings; an integer must be cast (add(c, '42', 'val')). So your second bullet is correct.
Persistence is not the same as Oracle nested‑table storage.
When you put a collection in a column, PostgreSQL stores it as an opaque varlena; you cannot join to it or index inside it without expanding it in every query. Oracle nested tables, by contrast, become real child tables that can be indexed and queried directly.
Hybrid but closer to an associative array.
Because keys are hash‑based strings, and because the structure is sparse and unbounded, pgcollection behaves more like Oracle’s associative array than like a nested table—in spite of its ability to be stored on disk. The absence of integer subscripts and relational indexing makes it less like a true nested‑table implementation.
