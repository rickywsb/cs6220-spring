ðŸ’¡ å®žçŽ°æ–¹å¼ç›¸å…³
Why did you choose to use ExpandedObjectHeader instead of a lighter struct or native C struct for in-memory layout?
â†’ æƒ³äº†è§£ä½¿ç”¨ PostgreSQL å†…éƒ¨çš„ expanded object API è€Œä¸æ˜¯è‡ªå®šä¹‰ç»“æž„çš„åŽŸå› ï¼Œæ˜¯ä¸ºäº†æ›´å¥½åœ°é›†æˆ PG å†…æ ¸ï¼Œè¿˜æ˜¯ä¸ºäº†å®žçŽ° flatten/expandï¼Ÿ
What are the design tradeoffs between using uthash versus using PostgreSQLâ€™s own hash table infrastructure (e.g., dynahash)?
â†’ uthash æ˜¯è½»é‡ä½†æ²¡æœ‰å†…å»ºçš„ memory context æ”¯æŒï¼ŒPG å†…ç½®çš„ hash table å¯èƒ½é›†æˆæ›´ç´§å¯†ã€‚
Is it safe to use a collection type as a field in composite types or pass between functions that cross memory contexts?
â†’ å½“å‰ memory context éš”ç¦»ç­–ç•¥æ˜¯å¦å…è®¸è·¨å‡½æ•°å®‰å…¨ä½¿ç”¨ï¼Œflatten æ˜¯å¦æ˜¯å¿…è¦æ­¥éª¤ï¼Ÿ
Why limit to only text as key? Any plans to support other key types like int or uuid in the future?
â†’ ç›®å‰åªæ”¯æŒ text ç±»åž‹ keyï¼Œä½†å®žé™…ä¸šåŠ¡ä¸­å¸¸è§ int/uuid ä½œä¸ºä¸»é”®ã€‚
Why isn't there support for nested collections (collections inside collections)?
â†’ æ˜¯å¦æœ‰è®¾è®¡é™åˆ¶ï¼Œæˆ–åªæ˜¯ v1 å°šæœªæ”¯æŒï¼Ÿæ˜¯å¦æœ‰è®¡åˆ’å®žçŽ°ç±»ä¼¼åµŒå¥— map ç»“æž„ï¼Ÿ



What are the advantages of pgcollection over JSON?
1. Strongly typed values
Unlike JSON, which stores data as untyped strings or loosely structured objects, pgcollection enforces a consistent data type for all values. When you create a collection, you can define that all values must be text, integer, date, or even complex types like record. This helps catch type errors early and allows PostgreSQL to optimize memory and operations more efficiently.

2. Fast key-based access (O(1) vs. linear search)
pgcollection uses an internal hash table (via uthash) to store and retrieve key-value pairs. This means accessing a value by key takes constant time, regardless of the size of the collection. In contrast, accessing a value in a JSON object within PL/pgSQL often involves parsing the entire structure and doing a linear scan, which becomes slower as the JSON grows.

3. Optimized for in-memory usage
pgcollection is designed for temporary, high-speed operations inside functions, especially in PL/pgSQL. All data lives in memory and never touches disk unless explicitly saved. This makes it ideal for use cases like caching, aggregation, or building intermediate results during a complex computation.

4. Native subscript syntax
Accessing elements in a collection is straightforward and readable: collection['key'] := 'value'; or collection['key']. Thereâ€™s no need to cast or extract from a JSON blob using functions like ->> or jsonb_extract_path_text(). This syntax improves developer productivity and clarity.

5. Built-in iteration tools
pgcollection supports iterators like first(), next(), key(), and value() to loop over elements in order. This is more natural and efficient than trying to unpack and traverse a JSON structure inside a PL/pgSQL loop. You donâ€™t need to call jsonb_each() or convert JSON into a temporary table â€” pgcollection provides direct, in-memory iteration.


How pgcollection really aligns (or not) with Oracle collection kinds
Aspect	Oracleâ€¯VARRAY / Nestedâ€‘table	Oracleâ€¯Associativeâ€¯array	pgcollection reality
Bounded vs. unbounded	VARRAY is boundedâ€¯; Nestedâ€‘table is unbounded	Unbounded	Unbounded until memory (or 1â€¯GB when flattened to disk) exhausts â€“ so this matches Nestedâ€‘table/associative array behaviour.
Index/key type	VARRAY/Nestedâ€‘table use integer subscripts starting atâ€¯1	Can be integer or string	Currently only text keys. You cannot use an integer subscript unless you cast it to text. Future work could add an integer path, but today it is stringâ€‘only.
Sparsity	VARRAY dense, Nestedâ€‘table can be sparse after DELETE	Associative arrays can be sparse	pgcollection is hashâ€‘based and therefore naturally sparse. Keys are not required to be contiguous or sequential.
Onâ€‘disk persistence	Nestedâ€‘table/ VARRAY columns stored as separate child tables or LOBs, support indexing and query	Associative array cannot be stored in a column	pgcollection can be stored in a column, but as a single varlena blob (max 1â€¯GB) â€“ there is no child table, no columnâ€‘level indexing, and the server must fully expand the blob to query it. So it is persistible like a nested table but without relational visibility or indexes.
Ordering semantics	VARRAY keeps positional order; Nestedâ€‘table loses order unless you ORDER BY; Associative array order undefined	pgcollection preserves insertion order until you call sort().	
Key takeâ€‘aways
Index datatype is indeed only text today.
All subscripts are stored as strings; an integer must be cast (add(c, '42', 'val')). So your second bullet is correct.
Persistence is not the same as Oracle nestedâ€‘table storage.
When you put a collection in a column, PostgreSQL stores it as an opaque varlena; you cannot join to it or index inside it without expanding it in every query. Oracle nested tables, by contrast, become real child tables that can be indexed and queried directly.
Hybrid but closer to an associative array.
Because keys are hashâ€‘based strings, and because the structure is sparse and unbounded, pgcollection behaves more like Oracleâ€™s associative array than like a nested tableâ€”in spite of its ability to be stored on disk. The absence of integer subscripts and relational indexing makes it less like a true nestedâ€‘table implementation.
